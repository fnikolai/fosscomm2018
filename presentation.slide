#+theme=black

Hey Ho Let's GO

Golang Workshop, Fosscomm Oct/2018


- Presenter:
[[http://github.com/fnikolai][Fotis Nikolaidis]]


- Credits:
[[manos.ikarios@gmail.com][Manos Ikarios]]
[[http://github.com/baijum/presentation/golang_workshop][Baiju Muthukadan]]
[[http://www.slideshare.net/spf13/go-firstapp][Steven Francia]]


* Fotis Nikolaidis 
- Contact
    nikolaidis.fotis@gmail.com
- Experience
    ~3 years @ French Alternative Energies and Atomic Energy Commission (CEA/DAM/DIF)
    ~3 years @ European Organization for Nuclear Research (IT-DSS-TAB, LHCb)
    ~3 years @ Foundation of Research and Technology (CARV, TNL)

- Others
    Receiver of ~3 years Marie Curie Grant (BigStorage ITN)


* Ground Rules

- Workshops are hard, everyone works at a different pace
- We will move on when about 50% are ready
- Slides are online, feel free to work ahead or catch up
- Talk -> exercise -> talk -> exercise ...
- Short Q&A in between

.image image/gopher.png 250 _ 

* Requirements
- Experience in some other programming language (Perl, Python, C, C++, Java,..)
- Laptop with Internet connectivity
- Operating system with Go support (GNU/Linux or Mac OS or Windows)
- Know how to use [[http://git-scm.com/doc][Git version control system]]
- Comfortable with one shell (Bash, Zsh, PowerShell etc.)


* Agenda

- General facts
- Running a hello world
- Reasons to use Go
- Development environment setup
- Types
- Functions
- Data structures
- Control structures
- Interfaces
- Concurrency


* Moore's law is failing
- The number of transistors on a chip doubles every year while the costs are halved
.image image/moores.png 400 _


* Amdahls' law is raising
- Performance upper bound when a fixed workload is moved to a more parallel environment

.image image/amdahls.png 400 _


* Facts

- Larges codebase
    - Reusable code:                if exists, use it
    - Minimal boilerplate code:     avoid lines that would not exist in pseudocode
    - Minimal side effects:         one component do not accidently interfer with another

- Thousands of developers
    - Simple language:              rapid productivity
    - Formal verification:          ensure that a component does what it claims to do    

- Diverse backgrounds
    - Clean code:                   if something similar exists, modify it
    - Language ecosystem:           standardize set of tools


* What is GO ?
- General Purpose Programing Language created at Google by R. Griesemer, R. Pike and K. Thompson in 2009
- Type-safe, memory-safe, garbage collected, with Built-in concurrency (CSP-style)
- [[http://commandcenter.blogspot.in/2012/06/less-is-exponentially-more.html][Simplicity]], 25 keywords (less than C,C++,Python etc.)

.image image/go2.png _ 500

* What is GO ? ..

- Two major compilers: gc & gccgo
- Operating Systems: Windows, GNU/Linux, Mac OS X, *BSD etc.
- Cross compilation on CPU Architectures: amd64, 386, arm etc.
- Targets to be fast both at compile time and runtime

.image image/go1.png _ 500


* Who uses Go?

- Google
- Uber
- Dropbox
- BBC
- Docker
- Disqus
- SoundCloud
- UserVoice
- [[https://github.com/golang/go/wiki/GoUsers][https://github.com/golang/go/wiki/GoUsers]]
- [[https://github.com/golang/go/wiki/SuccessStories][https://github.com/golang/go/wiki/SuccessStories]]



* Hello, Workshopers !
- Go programs are made up of *packages*: code organization, faster compilation 
.play code/hello.go

- To play with Go programming online: [[http://play.golang.org]]
- The presentation tool is written in GO
- The code snippets are linked to GO playground

* Keywords

- Keywords are reserved words that cannot be used as identifiers
- Provide structure and meaning to the language


    break        default      func         interface    select
    case         defer        go           map          struct
    chan         else         goto         package      switch
    const        fallthrough  if           range        type
    continue     for          import       return       var

- C Style Comments
    /* This is a multi-line comment
       ... and this is a the second line */

- C++ style Comments
    // Single line number
    // Starts with two slashes


* Built-In Functions

- Close channel: *close*
- Length and capacity: *len*, *cap*
- Allocation: *new*
- Making slices, maps and channels: *make*
- Appending to and copying slices: *append*, *copy*
- Deletion of map elements: *delete*
- Manipulating complex numbers: *complex*, *real*, *imag*
- Handling panics: *panic*, *recover*

* Primitive types

int, uint, int8, uint8, ...
bool, string
float32, float64
complex64, complex128

.play code/primitive1.go /START OMIT/,/END OMIT/

- [[https://golang.org/pkg/fmt]]

* Variables

- Type and initialization valures are explicitly specified
        var presenter bool = true
        var name, place string = "Fotis", "Fosscomm"

- Type is inferred from the values that is given for initialization
	    var place, name, presenter = "fosscomm2018", "Fotis", true // string, string, bool

- Inside a function, the _:=_ short assignment statement can be used instead of _var_
	    place, name, presenter :=  "fosscomm2018","Fotis", true    // string, string, bool

- The default value is 0 for numbers, false for Boolean, empy string for strings

* Variables 

- C syntax
        int random_number;
        int *pointer_to_number;
        int array_of_random_numbers[3];

        int main(int argc, char *argv[]) 
        int (*)(int a, int b);
        int (*)(int (*)(int, int), int)
        int (*(*)(int (*)(int, int), int))(int, int)


- Go syntax (no semicolons, *camelCase* naming, *UpperCase* denote visibility)
        randomNumber int                        // not visible outside the package
        pointerToRandomNumber *int              // not visisble outside the package
        ArrayOfRandomNumbers [3]int             // visible outside the package

        func main(int, []string) int
        func(int,int) int,
        func(func(int,int) int, int) int
        func(func(int,int) int, int) func(int, int) int


* Arrays

- An ordered container type with a fixed number of data
- The type *[n]T* is an array of n values of type T
- An array's length is part of its type, so arrays cannot be re-sized.
- if the length is different for two arrays, those are distinct incompatible types

    heights := [4]int{153, 146, 167, 170}
    colors := [3]string{"Red", "Green", "Blue"}
    i := colors[1]
    fmt.Println(i)


* Slices

- A _slice_ *[]T* points to an _array_ of values of type T
- Default value: _nil_. *len()* number of elements. *cap()* size of underlying array
- *append()* resizes the underlying array and appends a new element to the slice

.play code/slice.go /START OMIT/,/END OMIT/


- [[http://blog.golang.org/go-slices-usage-and-internals]]
- [[https://blog.golang.org/slices]]



* Maps

- A *map* maps keys to values. Can be allocated at declaration time
    fruitWeights := map[string]int{
        "Apple":  45,
        "Mango":  24,
        "Orange": 34,
    }

- Or before usage with the *make* keyword

.play code/maps.go /START OMIT/,/END OMIT/

- Assignment to *nil* map is provibited
- [[https://blog.golang.org/go-maps-in-action]]



* Type declarations

type [name] [specification]

- Custom types can be constructed based on built-in primitives
    // Celsius represent temperature in Celsius (a float64 type)
    type Celsius float64

    // Names represent an array of strings with length as 5
    type Names [5]string

- Or from composite structs (a collection of fields)
    // composite structs
    type Person struct {
        Name string
        Age  int
    }

* Struct Declaration

- Declare before usage
	var me Person
	me.Name = "Douglas Powers"
	me.Actor = "Mike Myers"

- Declare and initialize
	minime := Person{
		Name:  "Doublas Powers Jr.",
		Actor: "Mike Myers",
	}

- Composition over inheritance 
.play code/struct1.go /START OMIT/,/END OMIT/



* Method declaration

- Method is a function bound to a type (receiver) declared in the same package.
- Method bound to a struct:
    type Person struct {
        Name string
        Age  int
    }

    func (p Person) Major() bool { 
        return p.Age >= 18
    }

- Method bound to a custom type named Celsius (float64):

    // Celsius represent temperature in Celsius (a float64 type)
    type Celsius float64

    func (c Celsius) Freezing() bool { 
        return c <= 0
    }



* Function declaration

** func [name] ([params]) [return value]

A function to return sum of two _int_ values:

.play code/functiondeclaration1.go /START OMIT/,/END OMIT/


** func [name] ([params]) ([return values])

A function with multiple returned values:

.play code/functiondeclaration2.go /START OMIT/,/END OMIT/


* Errors

- Functions often return an built-in [[https://blog.golang.org/errors-are-values][error value]]. Nil error denotes success
- Calling code must handle the error or the compilation will fail

.play code/error1.go /START OMIT/,/END OMIT/

- Blank identifier  (*_* ) can be used to ignore return values from function
    import "strconv"
    import _ "github.com/lib/pq"

    x, _ := strconv.Atoi()


* If Conditions

- Syntax inspired by C. Curly brace is mandatory

.play code/if1.go /START OMIT/,/END OMIT/

- if statement can start with a short statement before the condition
- Variables declared by the statement are only in scope until the end of the if
- Variables declared are also available inside any of the else blocks

.play code/if2.go /START OMIT/,/END OMIT/


* Switch statement

- The cases are evaluated top to bottom until a match is found
- There is no automatic fall through. Use break for early termination
- Cases can be presented in comma-separated lists

.play code/switch1.go /START OMIT/,/END OMIT/

* Switch statement ...

If the switch has no expression it switches on true (useful to write an if-else-if-else chain)

.play code/switch2.go /START OMIT/,/END OMIT/



* For Loop

- The only looping construct (no while loop)
- Syntax inspired by C. Curly brace is mandatory
- No parenthesis (not even optional)

.play code/for1.go /START OMIT/,/END OMIT/

- Pre and post statements can be empty (and drop the semicolons!)

.play code/for2.go /START OMIT/,/END OMIT/


* Range Iterator

When iterating over a slice, range returns a tuple <index, element>

.play code/range1.go /START OMIT/,/END OMIT/

When iterating over a map,  range returns a tuple <key, element>

.play code/range2.go /START OMIT/,/END OMIT/

- Apart from syntantic sugar, _Range_ provides locality optimization 



* Challenge ~15 minutes
- Exercise 1: [[https://play.golang.org/p/wey131kXf7N][https://play.golang.org/p/wey131kXf7N]]
- [[https://play.golang.org/p/Zsz_JIQNN1B][Solution]]

.image image/gopher.png 400 _ 



* Pointers

- The type *T is a pointer to a T value. Its default value is _nil_.

    var i *int
    var p *Person

- The & operator generates a pointer to its operand.

    i := 42
    p = &i

- The * operator denotes the pointer's underlying value.

    fmt.Println(*p) // read i through the pointer p
    *p = 21         // set i through the pointer p

- This is known as "dereferencing" or "indirecting".

* Pointers ...

- Unlike C, Go has no pointer arithmetic, thus no pointers to unsafe memory.
    a := "hello"
    p := &a
    p += 4  // no, you can't

- Passing values has no side effects, but requires (deep) copy (large) structs
    func double(x int) {
        x *= 2
    }

- Passing references, side-effects posible (modifies the receiver)
    func double(x *int) {
        *x *= 2
    }
- Consistency: Let all methods have pointer receivers




* Defer statement

- Postpones the execution of a function until the surrounding function returns. 
- Executed in LIFO order
- Ensure a cleanup function is called later

.play code/defer1.go /START OMIT/,/END OMIT/


* Panic / Recovery

- A panic typically means something went unexpectedly wrong, or something that we are not prepared to handle gracefully
- Recover regains control of a panicking goroutine

.play code/panic.go /START OMIT/,/END OMIT/

- Equivalent to try-catch-finally

* Interface

- Interfaces provide a way to specify the behavior of an object
- A type can implement multiple interfaces
- Named collections of method signatures

    type Geometry interface {
        Area() float64
        Perimeter() float64
    }

* Interface ...

- An interface type is defined by a set of methods
- A value of interface type can hold any value that implements those methods
- Interfaces are satisfied implicitly
- A type implements an interface by implementing the methods.

* Interface ...

.play code/interface1.go /START OMIT/,/END OMIT/


* Challenge ~15 minutes
- Exercise 2: [[https://play.golang.org/p/wey131kXf7N][https://play.golang.org/p/wey131kXf7N]]
- [[https://play.golang.org/p/Zsz_JIQNN1B][Solution]]

.image image/gopher.png 400 _ 



* Communicating sequential processes

.image image/csp.png 400 _ 


* Goroutines

- Lightweight threads managed by the Go runtime
- Calling a function with _go_ keyword starts the goroutine

.play code/concurrency1.go /START OMIT/,/END OMIT/


* Channels  ...

- Goroutines can communicate to each other via channels (typed conduit)
- You can send and receive values of type _T_ with the channel operator: <-

    ch <- v    // Send v to channel ch.
    v := <-ch  // Receive from ch, and assign value to v.

- The data flows in the direction of the arrow.
- Channels must be created before use (default value is nil)

    ch := make(chan int)

- Sends and receives block until the other side is ready (bounded)
- Once a channel has been closed, you cannot send a value on this channel, but you can still receive from the channel.

* Synchronization via Channels


.play code/concurrency2.go /START OMIT/,/END OMIT/


* Synchronization via Mutexes

.play code/concurrency3.go /START OMIT/,/END OMIT/

* WaitGroup (WG)

- _sync.WaitGroup_ provides a goroutine synchronization mechanism in Golang
- A WaitGroup waits for a collection of goroutines to finish
- _sync.WaitGroup_ provides 3 methods: Add, Done and Wait.
- _Add_ method is used to identify how many goroutines need to be waited
- When a goroutine exits, it must call _Done_
- The main goroutine blocks on _Wait_

* Synchronization via WG (single routine)

.play code/concurrency5.go /START OMIT/,/END OMIT/

* Synchronization via WG (multi routines)

.play code/concurrency4.go /START OMIT/,/END OMIT/

- Termination order not guaranteed
- And should *not* be




* Challenge ~N minutes
- Exercise 3: [[https://play.golang.org/p/Zsz_JIQNN1B][https://play.golang.org/p/Zsz_JIQNN1B]]
- [[https://play.golang.org/p/io9jt6Z64Rb][Solution]]

.image image/gopher.png 400 _ 








* Go Proverbs

Don't communicate by sharing memory, share memory by communicating.

Concurrency is not parallelism.

Channels orchestrate; mutexes serialize.

The bigger the interface, the weaker the abstraction.

Make the zero value useful.

interface{} says nothing.

Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.

A little copying is better than a little dependency.

Syscall must always be guarded with build tags.

* Go Proverbs ...

Cgo must always be guarded with build tags.

Cgo is not Go.

With the unsafe package there are no guarantees.

Clear is better than clever.

Reflection is never clear.

Errors are values.

Don't just check errors, handle them gracefully.

Design the architecture, name the components, document the details.

Documentation is for users.

Don't panic.


